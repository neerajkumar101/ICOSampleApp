'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var fs = require('fs');
var run = require('subcomandante');
var series = require('run-series');
var ipfs = require('ipfs-api');
var multiaddr = require('multiaddr');
var rimraf = require('rimraf');
var shutdown = require('shutdown');
var path = require('path');
var join = path.join;
var bl = require('bl');
var once = require('once');

var ipfsDefaultPath = findIpfsExecutable();

var GRACE_PERIOD = 7500; // amount of ms to wait before sigkill

function findIpfsExecutable() {
  var rootPath = process.env.testpath ? process.env.testpath : __dirname;

  var appRoot = path.join(rootPath, '..');
  var depPath = path.join('go-ipfs-dep', 'go-ipfs', 'ipfs');
  var npm3Path = path.join(appRoot, '../', depPath);
  var npm2Path = path.join(appRoot, 'node_modules', depPath);

  try {
    fs.statSync(npm3Path);
    return npm3Path;
  } catch (e) {
    return npm2Path;
  }
}

function configureNode(node, conf, done) {
  var keys = Object.keys(conf);
  series(keys.map(function (key) {
    return function (cb) {
      var value = conf[key];
      var env = { env: node.env };

      run(node.exec, ['config', key, '--json', JSON.stringify(value)], env).on('error', cb).on('end', cb);
    };
  }), done);
}

// Consistent error handling
function parseConfig(path, done) {
  var file = fs.readFileSync(join(path, 'config'));

  try {
    var parsed = JSON.parse(file);
    done(null, parsed);
  } catch (err) {
    done(err);
  }
}

module.exports = function () {
  function Node(path, opts, disposable) {
    _classCallCheck(this, Node);

    this.path = path;
    this.opts = opts || {};
    this.exec = process.env.IPFS_EXEC || ipfsDefaultPath;
    this.subprocess = null;
    this.initialized = fs.existsSync(path);
    this.clean = true;
    this.env = Object.assign({}, process.env, { IPFS_PATH: path });

    if (this.opts.env) Object.assign(this.env, this.opts.env);
  }

  _createClass(Node, [{
    key: '_run',
    value: function _run(args, envArg, done) {
      run(this.exec, args, envArg).on('error', done).pipe(bl(function (err, result) {
        if (err) {
          return done(err);
        }

        done(null, result.toString().trim());
      }));
    }
  }, {
    key: 'init',
    value: function init(initOpts, done) {
      var _this = this;

      if (!done) {
        done = initOpts;
        initOpts = {};
      }

      var keySize = initOpts.keysize || 2048;

      if (initOpts.directory && initOpts.directory !== this.path) {
        this.path = initOpts.directory;
        this.env.IPFS_PATH = this.path;
      }

      run(this.exec, ['init', '-b', keySize], { env: this.env }).on('error', done).pipe(bl(function (err, buf) {
        if (err) return done(err);

        configureNode(_this, _this.opts, function (err) {
          if (err) {
            return done(err);
          }

          _this.clean = false;
          _this.initialized = true;

          done(null, _this);
        });
      }));

      if (this.disposable) {
        shutdown.addHandler('disposable', 1, this.shutdown.bind(this));
      }
    }

    // cleanup tmp files
    // TODO: this is a bad name for a function. a user may call this expecting
    // something similar to "stopDaemon()". consider changing it. - @jbenet

  }, {
    key: 'shutdown',
    value: function shutdown(done) {
      if (!this.clean && this.disposable) {
        rimraf(this.path, function (err) {
          if (err) throw err;
          done();
        });
      }
    }
  }, {
    key: 'startDaemon',
    value: function startDaemon(flags, done) {
      if (typeof flags === 'function' && typeof done === 'undefined') {
        done = flags;
        flags = [];
      }

      var node = this;
      parseConfig(node.path, function (err, conf) {
        if (err) return done(err);

        var stdout = '';
        var args = ['daemon'].concat(flags || []);

        // strategy:
        // - run subprocess
        // - listen for API addr on stdout (success)
        // - or an early exit or error (failure)
        node.subprocess = run(node.exec, args, { env: node.env });
        node.subprocess.on('error', onErr).on('data', onData);

        // done2 is called to call done after removing the event listeners
        var _done = function done2(err, val) {
          node.subprocess.removeListener('data', onData);
          node.subprocess.removeListener('error', onErr);
          if (err) {
            node.killProcess(function () {}); // we failed. kill, just to be sure...
          }
          done(err, val);
          _done = function done2() {}; // in case it gets called twice
        };

        function onErr(err) {
          if (String(err).match('daemon is running')) {
            // we're good
            _done(null, ipfs(conf.Addresses.API));

            // TODO: I don't think this case is OK at all...
            // When does the daemon outout "daemon is running" ?? seems old.
            // Someone should check on this... - @jbenet
          } else if (String(err).match('non-zero exit code')) {
            // exited with an error on startup, before we removed listeners
            _done(err);
          } else {
            _done(err);
          }
        }

        function onData(data) {
          data = String(data);
          stdout += data;

          if (!data.trim().match(/Daemon is ready/)) {
            return; // not ready yet, keep waiting.
          }

          var apiM = stdout.match(/API server listening on (.*)\n/);
          if (apiM) {
            // found the API server listening. extract the addr.
            node.apiAddr = apiM[1];
          } else {
            // daemon ready but no API server? seems wrong...
            _done(new Error('daemon ready without api'));
          }

          var gatewayM = stdout.match(/Gateway \((readonly|writable)\) server listening on (.*)\n/);
          if (gatewayM) {
            // found the Gateway server listening. extract the addr.
            node.gatewayAddr = gatewayM[1];
          }

          var addr = multiaddr(node.apiAddr).nodeAddress();
          var api = ipfs(node.apiAddr);
          api.apiHost = addr.address;
          api.apiPort = addr.port;

          // We are happyly listening, so let's not hide other errors
          node.subprocess.removeListener('error', onErr);

          _done(null, api);
        }
      });
    }
  }, {
    key: 'stopDaemon',
    value: function stopDaemon(done) {
      if (!done) {
        done = function done() {};
      }

      if (!this.subprocess) {
        return done();
      }

      this.killProcess(done);
    }
  }, {
    key: 'killProcess',
    value: function killProcess(done) {
      var _this2 = this;

      // need a local var for the closure, as we clear the var.
      var subprocess = this.subprocess;
      var timeout = setTimeout(function () {
        subprocess.kill('SIGKILL');
        done();
      }, GRACE_PERIOD);

      subprocess.on('close', function () {
        clearTimeout(timeout);
        _this2.subprocess = null;
        done();
      });

      subprocess.kill('SIGTERM');
      this.subprocess = null;
    }
  }, {
    key: 'daemonPid',
    value: function daemonPid() {
      return this.subprocess && this.subprocess.pid;
    }
  }, {
    key: 'getConfig',
    value: function getConfig(key, done) {
      if (typeof key === 'function') {
        done = key;
        key = '';
      }

      this._run(['config', key], { env: this.env }, done);
    }
  }, {
    key: 'setConfig',
    value: function setConfig(key, value, done) {
      done = once(done);
      run(this.exec, ['config', key, value, '--json'], { env: this.env }).on('error', done).on('data', function () {}).on('end', function () {
        return done();
      });
    }
  }, {
    key: 'replaceConf',
    value: function replaceConf(file, done) {
      this._run(['config', 'replace', file], { env: this.env }, done);
    }
  }, {
    key: 'version',
    value: function version(done) {
      this._run(['version'], {}, done);
    }
  }]);

  return Node;
}();